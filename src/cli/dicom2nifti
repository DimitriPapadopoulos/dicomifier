#!/usr/bin/env python

import argparse
import glob
import logging
import json
import math
import os
import sys

import numpy
import odil

import dicomifier

def main():
    parser = argparse.ArgumentParser(description="Convert DICOM to NIfTI")
    parser.add_argument(
        "dicom", nargs="+", help="DICOM file, directory or DICOMDIR")
    parser.add_argument("destination", help="Output directory")
    parser.add_argument(
        "--dtype", "-d", default="single", type=lambda x: getattr(numpy, x), 
        help="Pixel type")
    parser.add_argument(
        "--zip", "-z", action="store_true", help="Compress NIfTI files")
    parser.add_argument(
        "--pretty-print", "-p", action="store_true", 
        help="Pretty-print JSON files")
    parser.add_argument(
        "--verbosity", "-v",
        choices=["warning", "info", "debug"], default="warning")
    
    arguments = vars(parser.parse_args())
    
    verbosity = arguments.pop("verbosity")
    logging.getLogger().setLevel(verbosity.upper())
    
    try:
        convert(**arguments)
    except Exception as e:
        if verbosity == "debug":
            raise
        else:
            parser.error(e)

def convert(dicom, destination, dtype, pretty_print, zip):
    
    if os.path.isdir(destination) and len(os.listdir(destination)) > 0:
        logging.warning("{} is not empty".format(destination))
    
    dicom_files = get_files(dicom)
    series = split_series(dicom_files)
    
    logging.info("{} series found".format(len(series)))
    
    study_directories = {}
    series_directories = {}
    
    for series_files in series.values():
        nifti_data = convert_series(series_files, dtype)
        if nifti_data is None:
            # No image in the series
            continue
        write_nifti(
            nifti_data, destination, pretty_print, zip, 
            study_directories, series_directories)

def get_files(dicom):
    dicom_files = set()
    for entry in dicom:
        entry = os.path.abspath(entry)
        
        if os.path.isdir(entry):
            for dirpath, dirnames, filenames in os.walk(entry):
                for filename in filenames:
                    if filename.upper() == "DICOMDIR":
                        dicom_files.update(
                            get_dicomdir_files(os.path.join(dirpath, filename)))
                    else:
                        dicom_files.add(os.path.join(dirpath, filename))
        elif os.path.basename(entry).upper() == "DICOMDIR":
            dicom_files.update(get_dicomdir_files(entry))
        else:
            dicom_files.add(entry)
    
    return dicom_files

def get_dicomdir_files(path):
    dicom_files = []
    _, dicomdir = odil.read(path)
    for record in dicomdir.as_data_set("DirectoryRecordSequence"):
        if record.as_string("DirectoryRecordType")[0] == "IMAGE":
            dicom_files.append(
                os.path.join(
                    os.path.dirname(path),
                    *record.as_string("ReferencedFileID")))
    
    return dicom_files

def split_series(dicom_files):
    logging.info(
        "Splitting {} DICOM file{} in series".format(
            len(dicom_files), "s" if len(dicom_files)>1 else ""))
    
    def until_series_instance_uid(tag):
        tag = tag.group*2**16 + tag.element
        return (tag > 0x0200010) # StudyInstanceUID
    
    series = {}
    for file_ in dicom_files:
        _, data_set = odil.read(file_, halt_condition=until_series_instance_uid)
        series_instance_uid = data_set.as_string("SeriesInstanceUID")[0]
        series.setdefault(series_instance_uid, []).append(file_)
    
    return series

def convert_series(series_files, dtype):
    def binary_as_bytes(data):
        if "InlineBinary" in data:
            data["InlineBinary"] = data["InlineBinary"].encode("ascii")
        return data
    
    logging.info(
        "Reading {} DICOM file{}".format(
            len(series_files), "s" if len(series_files)>1 else ""))
    dicom_data_sets = [odil.read(x)[1] for x in series_files]
    
    # Filter non-images
    dicom_data_sets = [x for x in dicom_data_sets if "PixelData" in x]
    if len(dicom_data_sets) == 0:
        return None
    
    dicom_data_sets = [
        json.loads(odil.as_json(x), object_hook=binary_as_bytes) 
        for x in dicom_data_sets]
    
    nifti_data = dicomifier.dicom_to_nifti.convert(dicom_data_sets, dtype)
    
    return nifti_data
    
def write_nifti(
        nifti_data, destination, pretty_print, zip, 
        study_directories, series_directories):
    for image, meta_data in nifti_data:
        # Generate a study directory name
        study_instance_uid = meta_data["StudyInstanceUID"][0]
        if study_instance_uid not in study_directories:
            study_id = meta_data.get("StudyID", [None])[0]
            study_description = meta_data.get("StudyDescription", [None])[0]
            
            directory = []
            if study_id is not None:
                directory.append(study_id)
            else:
                directory.append(str(1+len(study_directories)))
            if study_description is not None:
                directory.append(study_description)
            directory = "_".join(directory)
            
            study_directories[study_instance_uid] = directory
            series_directories[study_instance_uid] = {}
        
        # Generate a series directory name
        series_instance_uid = meta_data["SeriesInstanceUID"][0]
        if not series_directories.get(series_instance_uid):
            series_number = meta_data.get("SeriesNumber", [None])[0]
            series_description = meta_data.get("SeriesDescription", [None])[0]
            
            directory = []
            if series_number:
                directory.append(str(series_number))
            else:
                directory.append(str(1+len(series_directories[study_instance_uid])))
            if series_description:
                directory.append(series_description)
            directory = "_".join(directory)
            
            series_directories[study_instance_uid][series_instance_uid] = directory
    
    # Write one nii+json per stack
    for index, (image, meta_data) in enumerate(nifti_data):
        study_instance_uid = meta_data["StudyInstanceUID"][0]
        series_instance_uid = meta_data["SeriesInstanceUID"][0]
        
        destination_directory = os.path.join(
            destination, 
            study_directories[study_instance_uid],
            series_directories[study_instance_uid][series_instance_uid])
        
        if not os.path.isdir(destination_directory):
            os.makedirs(destination_directory)
        
        destination_root = os.path.join(destination_directory, str(1+index))
        
        suffix = ".nii"
        if zip:
            suffix += ".gz"
        image.write(destination_root+suffix)
        
        kwargs = {}
        if pretty_print:
            kwargs = {"sort_keys": True, "indent": 4}
        json.dump(
            meta_data, open(destination_root+".json", "w"), 
            cls=dicomifier.MetaData.JSONEncoder, **kwargs)

if __name__ == "__main__":
    sys.exit(main())
