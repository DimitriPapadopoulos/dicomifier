#!${PYTHON_EXECUTABLE}

from __future__ import print_function
import argparse
import itertools
import logging
import math
import os
import re
import sys
import tempfile
import shutil
import zipfile

import odil

import dicomifier

def main():
    parser = argparse.ArgumentParser(
        description="Convert Bruker images to DICOM")
    subparsers = parser.add_subparsers(help="Sub-commands help")

    list_parser = subparsers.add_parser(
        "list", help="List series and reconstructions in a Bruker directory")
    list_parser.add_argument(
        "source", help="Directory containing the Bruker data")
    list_parser.add_argument(
        "--verbosity", "-v",
        choices=["warning", "info", "debug"], default="warning")
    list_parser.set_defaults(function=list_)

    convert_parser = subparsers.add_parser(
        "convert", help="Convert Bruker images")
    convert_parser.add_argument(
        "source", help="Directory containing the Bruker data")
    convert_parser.add_argument("destination", help="Output directory")
    convert_parser.add_argument(
        "--reconstruction", "-r", action="append",
        dest="reconstructions",
        help="Series and reconstruction to convert (format seriesNumber:reconstructionNumber)")
    convert_parser.add_argument(
        "--transfer-syntax", "-t", type=lambda x: getattr(odil.registry, x),
        default="ImplicitVRLittleEndian",
        help="Transfer syntax of the output files")
    convert_parser.add_argument(
        "--multiframe", "-m", action="store_true",
        help="Generate multiframe dicom files")
    convert_parser.add_argument(
        "--layout", "-l", choices=["nested", "flat"], default="nested",
        help="Layout of the DICOM files on the disk")
    convert_parser.add_argument(
        "--dicomdir", "-d", action="store_true", help="Create a DICOMDIR")
    convert_parser.add_argument(
        "--verbosity", "-v",
        choices=["warning", "info", "debug"], default="warning")
    convert_parser.set_defaults(function=convert)

    arguments = vars(parser.parse_args())
    
    if "function" not in arguments:
        parser.error("too few arguments")

    verbosity = arguments.pop("verbosity")
    logging.basicConfig(
        level=verbosity.upper(), 
        format="%(levelname)s - %(name)s: %(message)s")

    function = arguments.pop("function")
    source = arguments.pop("source")

    #create tmp directory in the system tmp location
    extractdir = tempfile.mkdtemp()
    try:
        # try to extract the archive
        zip_obj = zipfile.ZipFile(source)
        zip_obj.extractall(extractdir)
    except:
        # source is not a pvDataSet archive, so it should be a "normal" directory
        arguments["source"] = source
    else:
        # get directories in the extract area
        namelist = os.listdir(extractdir)
        for element in namelist :
            elementpath = os.path.join(".",extractdir,element)
            if (os.path.isdir(elementpath)):
                arguments["source"] = elementpath
    finally:
        try:
            function(**arguments)
        except Exception as e:
            if verbosity == "debug":
                raise
            else:
                parser.error(e)
        #delete directory here
        shutil.rmtree(extractdir)

def list_(source):
    """ List series and reconstructions information for the directory/archive given in parameter

        :param source: path of the element to browse
    """

    directory = dicomifier.bruker.Directory()

    subjects = dicomifier.bruker.Directory.list_subjects(source)
    for subject_source in subjects :
        series_and_reconstructions = sorted(
            directory.get_series_and_reco(subject_source).items(),
            key=lambda x: (int(x[0]), [int(y) for y in x[1]]))

        for series, reconstructions in series_and_reconstructions:
            directory.load(os.path.join(subject_source, series))
            for reconstruction in reconstructions:
                bruker_data_set = directory.get_dataset(
                    "{}{:04d}".format(series, int(reconstruction)))
                bruker_dict = {k:v.value for k,v in bruker_data_set.items()}
                print(
                    "{}:{} - {} ({})".format(
                        series, reconstruction,
                        bruker_dict.get("VisuAcquisitionProtocol", ["(none)"])[0],
                        bruker_dict.get("RECO_mode", ["none"])[0]
                    )
                )

def convert(
        source, destination, reconstructions, transfer_syntax,
        layout, dicomdir, multiframe):
    """ Function that converts a source file (bruker) into a destination file (dicom)

        :param source: source file
        :param destination: destination file
        :param reconstructions: series and reconstruction to convert inside the source file
        :param transfer_syntax: target transfer syntax
        :param dicomdir: Create a dicomdir or no
        :param multiframe: Whether generate dicom multiframe files or no
    """
    if os.path.isdir(destination) and len(os.listdir(destination)) > 0:
        dicomifier.logger.warning("{} is not empty".format(destination))

    directories = dicomifier.bruker.Directory.list_subjects(source)
    
    if reconstructions:
        reconstructions = [
            [int(x) for x in r.split(":")] for r in reconstructions]

    Writers = {
        "nested": dicomifier.bruker_to_dicom.io.NestedDICOMWriter,
        "flat": dicomifier.bruker_to_dicom.io.FlatDICOMWriter}
    writer = Writers[layout](destination, True, transfer_syntax)
    
    for path in directories:
        dicomifier.bruker_to_dicom.convert.convert_directory(
            path, destination, reconstructions, dicomdir, multiframe, writer)

if __name__ == "__main__": 
    sys.exit(main())
